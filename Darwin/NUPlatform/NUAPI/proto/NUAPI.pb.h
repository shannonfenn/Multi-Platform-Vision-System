// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NUAPI.proto

#ifndef PROTOBUF_NUAPI_2eproto__INCLUDED
#define PROTOBUF_NUAPI_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace API {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_NUAPI_2eproto();
void protobuf_AssignDesc_NUAPI_2eproto();
void protobuf_ShutdownFile_NUAPI_2eproto();

class Message;
class Image;
class VisionFieldObject;
class VisionClassifiedSegment;
class VisionClassifiedImage;
class Vision;
class Motor;
class SensorData;
class LocalisationFieldObject;
class Localisation;
class Vector;

enum Message_Type {
  Message_Type_SENSOR_DATA = 1,
  Message_Type_VISION = 2,
  Message_Type_LOCALISATION = 3
};
bool Message_Type_IsValid(int value);
const Message_Type Message_Type_Type_MIN = Message_Type_SENSOR_DATA;
const Message_Type Message_Type_Type_MAX = Message_Type_LOCALISATION;
const int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Type_descriptor();
inline const ::std::string& Message_Type_Name(Message_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Type_descriptor(), value);
}
inline bool Message_Type_Parse(
    const ::std::string& name, Message_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
enum VisionFieldObject_Type {
  VisionFieldObject_Type_CIRCLE = 1,
  VisionFieldObject_Type_RECTANGLE = 2,
  VisionFieldObject_Type_POLYGON = 3,
  VisionFieldObject_Type_UNKNOWN = 4
};
bool VisionFieldObject_Type_IsValid(int value);
const VisionFieldObject_Type VisionFieldObject_Type_Type_MIN = VisionFieldObject_Type_CIRCLE;
const VisionFieldObject_Type VisionFieldObject_Type_Type_MAX = VisionFieldObject_Type_UNKNOWN;
const int VisionFieldObject_Type_Type_ARRAYSIZE = VisionFieldObject_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* VisionFieldObject_Type_descriptor();
inline const ::std::string& VisionFieldObject_Type_Name(VisionFieldObject_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    VisionFieldObject_Type_descriptor(), value);
}
inline bool VisionFieldObject_Type_Parse(
    const ::std::string& name, VisionFieldObject_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VisionFieldObject_Type>(
    VisionFieldObject_Type_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_Type Type;
  static const Type SENSOR_DATA = Message_Type_SENSOR_DATA;
  static const Type VISION = Message_Type_VISION;
  static const Type LOCALISATION = Message_Type_LOCALISATION;
  static inline bool Type_IsValid(int value) {
    return Message_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Message_Type_Type_MIN;
  static const Type Type_MAX =
    Message_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Message_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Message_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Message_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Message_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .API.Message.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::API::Message_Type type() const;
  inline void set_type(::API::Message_Type value);

  // required uint64 utc_timestamp = 2;
  inline bool has_utc_timestamp() const;
  inline void clear_utc_timestamp();
  static const int kUtcTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 utc_timestamp() const;
  inline void set_utc_timestamp(::google::protobuf::uint64 value);

  // optional .API.SensorData sensor_data = 3;
  inline bool has_sensor_data() const;
  inline void clear_sensor_data();
  static const int kSensorDataFieldNumber = 3;
  inline const ::API::SensorData& sensor_data() const;
  inline ::API::SensorData* mutable_sensor_data();
  inline ::API::SensorData* release_sensor_data();
  inline void set_allocated_sensor_data(::API::SensorData* sensor_data);

  // optional .API.Vision vision = 4;
  inline bool has_vision() const;
  inline void clear_vision();
  static const int kVisionFieldNumber = 4;
  inline const ::API::Vision& vision() const;
  inline ::API::Vision* mutable_vision();
  inline ::API::Vision* release_vision();
  inline void set_allocated_vision(::API::Vision* vision);

  // optional .API.Localisation localisation = 5;
  inline bool has_localisation() const;
  inline void clear_localisation();
  static const int kLocalisationFieldNumber = 5;
  inline const ::API::Localisation& localisation() const;
  inline ::API::Localisation* mutable_localisation();
  inline ::API::Localisation* release_localisation();
  inline void set_allocated_localisation(::API::Localisation* localisation);

  // @@protoc_insertion_point(class_scope:API.Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_utc_timestamp();
  inline void clear_has_utc_timestamp();
  inline void set_has_sensor_data();
  inline void clear_has_sensor_data();
  inline void set_has_vision();
  inline void clear_has_vision();
  inline void set_has_localisation();
  inline void clear_has_localisation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 utc_timestamp_;
  ::API::SensorData* sensor_data_;
  ::API::Vision* vision_;
  ::API::Localisation* localisation_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  Image* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:API.Image)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class VisionFieldObject : public ::google::protobuf::Message {
 public:
  VisionFieldObject();
  virtual ~VisionFieldObject();

  VisionFieldObject(const VisionFieldObject& from);

  inline VisionFieldObject& operator=(const VisionFieldObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisionFieldObject& default_instance();

  void Swap(VisionFieldObject* other);

  // implements Message ----------------------------------------------

  VisionFieldObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VisionFieldObject& from);
  void MergeFrom(const VisionFieldObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VisionFieldObject_Type Type;
  static const Type CIRCLE = VisionFieldObject_Type_CIRCLE;
  static const Type RECTANGLE = VisionFieldObject_Type_RECTANGLE;
  static const Type POLYGON = VisionFieldObject_Type_POLYGON;
  static const Type UNKNOWN = VisionFieldObject_Type_UNKNOWN;
  static inline bool Type_IsValid(int value) {
    return VisionFieldObject_Type_IsValid(value);
  }
  static const Type Type_MIN =
    VisionFieldObject_Type_Type_MIN;
  static const Type Type_MAX =
    VisionFieldObject_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    VisionFieldObject_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return VisionFieldObject_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return VisionFieldObject_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return VisionFieldObject_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .API.VisionFieldObject.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::API::VisionFieldObject_Type type() const;
  inline void set_type(::API::VisionFieldObject_Type value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool visible = 4;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 4;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional float screen_x = 5;
  inline bool has_screen_x() const;
  inline void clear_screen_x();
  static const int kScreenXFieldNumber = 5;
  inline float screen_x() const;
  inline void set_screen_x(float value);

  // optional float screen_y = 6;
  inline bool has_screen_y() const;
  inline void clear_screen_y();
  static const int kScreenYFieldNumber = 6;
  inline float screen_y() const;
  inline void set_screen_y(float value);

  // optional float rotation = 7;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 7;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional uint32 radius = 8;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 8;
  inline ::google::protobuf::uint32 radius() const;
  inline void set_radius(::google::protobuf::uint32 value);

  // optional uint32 width = 9;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 9;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 10;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 10;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // repeated uint32 points = 11;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 11;
  inline ::google::protobuf::uint32 points(int index) const;
  inline void set_points(int index, ::google::protobuf::uint32 value);
  inline void add_points(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      points() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_points();

  // @@protoc_insertion_point(class_scope:API.VisionFieldObject)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_screen_x();
  inline void clear_has_screen_x();
  inline void set_has_screen_y();
  inline void clear_has_screen_y();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 id_;
  ::std::string* name_;
  bool visible_;
  float screen_x_;
  float screen_y_;
  float rotation_;
  ::google::protobuf::uint32 radius_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > points_;
  ::google::protobuf::uint32 height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static VisionFieldObject* default_instance_;
};
// -------------------------------------------------------------------

class VisionClassifiedSegment : public ::google::protobuf::Message {
 public:
  VisionClassifiedSegment();
  virtual ~VisionClassifiedSegment();

  VisionClassifiedSegment(const VisionClassifiedSegment& from);

  inline VisionClassifiedSegment& operator=(const VisionClassifiedSegment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisionClassifiedSegment& default_instance();

  void Swap(VisionClassifiedSegment* other);

  // implements Message ----------------------------------------------

  VisionClassifiedSegment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VisionClassifiedSegment& from);
  void MergeFrom(const VisionClassifiedSegment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 start_x = 1;
  inline bool has_start_x() const;
  inline void clear_start_x();
  static const int kStartXFieldNumber = 1;
  inline ::google::protobuf::uint32 start_x() const;
  inline void set_start_x(::google::protobuf::uint32 value);

  // optional uint32 start_y = 2;
  inline bool has_start_y() const;
  inline void clear_start_y();
  static const int kStartYFieldNumber = 2;
  inline ::google::protobuf::uint32 start_y() const;
  inline void set_start_y(::google::protobuf::uint32 value);

  // optional uint32 end_x = 3;
  inline bool has_end_x() const;
  inline void clear_end_x();
  static const int kEndXFieldNumber = 3;
  inline ::google::protobuf::uint32 end_x() const;
  inline void set_end_x(::google::protobuf::uint32 value);

  // optional uint32 end_y = 4;
  inline bool has_end_y() const;
  inline void clear_end_y();
  static const int kEndYFieldNumber = 4;
  inline ::google::protobuf::uint32 end_y() const;
  inline void set_end_y(::google::protobuf::uint32 value);

  // optional uint32 colour = 5;
  inline bool has_colour() const;
  inline void clear_colour();
  static const int kColourFieldNumber = 5;
  inline ::google::protobuf::uint32 colour() const;
  inline void set_colour(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:API.VisionClassifiedSegment)
 private:
  inline void set_has_start_x();
  inline void clear_has_start_x();
  inline void set_has_start_y();
  inline void clear_has_start_y();
  inline void set_has_end_x();
  inline void clear_has_end_x();
  inline void set_has_end_y();
  inline void clear_has_end_y();
  inline void set_has_colour();
  inline void clear_has_colour();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 start_x_;
  ::google::protobuf::uint32 start_y_;
  ::google::protobuf::uint32 end_x_;
  ::google::protobuf::uint32 end_y_;
  ::google::protobuf::uint32 colour_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static VisionClassifiedSegment* default_instance_;
};
// -------------------------------------------------------------------

class VisionClassifiedImage : public ::google::protobuf::Message {
 public:
  VisionClassifiedImage();
  virtual ~VisionClassifiedImage();

  VisionClassifiedImage(const VisionClassifiedImage& from);

  inline VisionClassifiedImage& operator=(const VisionClassifiedImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VisionClassifiedImage& default_instance();

  void Swap(VisionClassifiedImage* other);

  // implements Message ----------------------------------------------

  VisionClassifiedImage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VisionClassifiedImage& from);
  void MergeFrom(const VisionClassifiedImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 num_segments = 1;
  inline bool has_num_segments() const;
  inline void clear_num_segments();
  static const int kNumSegmentsFieldNumber = 1;
  inline ::google::protobuf::uint32 num_segments() const;
  inline void set_num_segments(::google::protobuf::uint32 value);

  // repeated .API.VisionClassifiedSegment segment = 2;
  inline int segment_size() const;
  inline void clear_segment();
  static const int kSegmentFieldNumber = 2;
  inline const ::API::VisionClassifiedSegment& segment(int index) const;
  inline ::API::VisionClassifiedSegment* mutable_segment(int index);
  inline ::API::VisionClassifiedSegment* add_segment();
  inline const ::google::protobuf::RepeatedPtrField< ::API::VisionClassifiedSegment >&
      segment() const;
  inline ::google::protobuf::RepeatedPtrField< ::API::VisionClassifiedSegment >*
      mutable_segment();

  // @@protoc_insertion_point(class_scope:API.VisionClassifiedImage)
 private:
  inline void set_has_num_segments();
  inline void clear_has_num_segments();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::API::VisionClassifiedSegment > segment_;
  ::google::protobuf::uint32 num_segments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static VisionClassifiedImage* default_instance_;
};
// -------------------------------------------------------------------

class Vision : public ::google::protobuf::Message {
 public:
  Vision();
  virtual ~Vision();

  Vision(const Vision& from);

  inline Vision& operator=(const Vision& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vision& default_instance();

  void Swap(Vision* other);

  // implements Message ----------------------------------------------

  Vision* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vision& from);
  void MergeFrom(const Vision& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .API.Image image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::API::Image& image() const;
  inline ::API::Image* mutable_image();
  inline ::API::Image* release_image();
  inline void set_allocated_image(::API::Image* image);

  // repeated .API.VisionFieldObject field_object = 2;
  inline int field_object_size() const;
  inline void clear_field_object();
  static const int kFieldObjectFieldNumber = 2;
  inline const ::API::VisionFieldObject& field_object(int index) const;
  inline ::API::VisionFieldObject* mutable_field_object(int index);
  inline ::API::VisionFieldObject* add_field_object();
  inline const ::google::protobuf::RepeatedPtrField< ::API::VisionFieldObject >&
      field_object() const;
  inline ::google::protobuf::RepeatedPtrField< ::API::VisionFieldObject >*
      mutable_field_object();

  // optional .API.VisionClassifiedImage classified_image = 3;
  inline bool has_classified_image() const;
  inline void clear_classified_image();
  static const int kClassifiedImageFieldNumber = 3;
  inline const ::API::VisionClassifiedImage& classified_image() const;
  inline ::API::VisionClassifiedImage* mutable_classified_image();
  inline ::API::VisionClassifiedImage* release_classified_image();
  inline void set_allocated_classified_image(::API::VisionClassifiedImage* classified_image);

  // @@protoc_insertion_point(class_scope:API.Vision)
 private:
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_classified_image();
  inline void clear_has_classified_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::API::Image* image_;
  ::google::protobuf::RepeatedPtrField< ::API::VisionFieldObject > field_object_;
  ::API::VisionClassifiedImage* classified_image_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static Vision* default_instance_;
};
// -------------------------------------------------------------------

class Motor : public ::google::protobuf::Message {
 public:
  Motor();
  virtual ~Motor();

  Motor(const Motor& from);

  inline Motor& operator=(const Motor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Motor& default_instance();

  void Swap(Motor* other);

  // implements Message ----------------------------------------------

  Motor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Motor& from);
  void MergeFrom(const Motor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional float position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline float position() const;
  inline void set_position(float value);

  // optional float velocity = 3;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  inline float velocity() const;
  inline void set_velocity(float value);

  // optional float acceleration = 4;
  inline bool has_acceleration() const;
  inline void clear_acceleration();
  static const int kAccelerationFieldNumber = 4;
  inline float acceleration() const;
  inline void set_acceleration(float value);

  // optional float target = 5;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 5;
  inline float target() const;
  inline void set_target(float value);

  // optional float stiffness = 6;
  inline bool has_stiffness() const;
  inline void clear_stiffness();
  static const int kStiffnessFieldNumber = 6;
  inline float stiffness() const;
  inline void set_stiffness(float value);

  // optional float current = 7;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 7;
  inline float current() const;
  inline void set_current(float value);

  // optional float torque = 8;
  inline bool has_torque() const;
  inline void clear_torque();
  static const int kTorqueFieldNumber = 8;
  inline float torque() const;
  inline void set_torque(float value);

  // optional float temperature = 9;
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 9;
  inline float temperature() const;
  inline void set_temperature(float value);

  // @@protoc_insertion_point(class_scope:API.Motor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_acceleration();
  inline void clear_has_acceleration();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_stiffness();
  inline void clear_has_stiffness();
  inline void set_has_current();
  inline void clear_has_current();
  inline void set_has_torque();
  inline void clear_has_torque();
  inline void set_has_temperature();
  inline void clear_has_temperature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  float position_;
  float velocity_;
  float acceleration_;
  float target_;
  float stiffness_;
  float current_;
  float torque_;
  float temperature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static Motor* default_instance_;
};
// -------------------------------------------------------------------

class SensorData : public ::google::protobuf::Message {
 public:
  SensorData();
  virtual ~SensorData();

  SensorData(const SensorData& from);

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorData& default_instance();

  void Swap(SensorData* other);

  // implements Message ----------------------------------------------

  SensorData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SensorData& from);
  void MergeFrom(const SensorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .API.Motor motor = 1;
  inline int motor_size() const;
  inline void clear_motor();
  static const int kMotorFieldNumber = 1;
  inline const ::API::Motor& motor(int index) const;
  inline ::API::Motor* mutable_motor(int index);
  inline ::API::Motor* add_motor();
  inline const ::google::protobuf::RepeatedPtrField< ::API::Motor >&
      motor() const;
  inline ::google::protobuf::RepeatedPtrField< ::API::Motor >*
      mutable_motor();

  // optional .API.Vector accelerometer = 2;
  inline bool has_accelerometer() const;
  inline void clear_accelerometer();
  static const int kAccelerometerFieldNumber = 2;
  inline const ::API::Vector& accelerometer() const;
  inline ::API::Vector* mutable_accelerometer();
  inline ::API::Vector* release_accelerometer();
  inline void set_allocated_accelerometer(::API::Vector* accelerometer);

  // optional .API.Vector gyro = 3;
  inline bool has_gyro() const;
  inline void clear_gyro();
  static const int kGyroFieldNumber = 3;
  inline const ::API::Vector& gyro() const;
  inline ::API::Vector* mutable_gyro();
  inline ::API::Vector* release_gyro();
  inline void set_allocated_gyro(::API::Vector* gyro);

  // optional .API.Vector orientation = 4;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  inline const ::API::Vector& orientation() const;
  inline ::API::Vector* mutable_orientation();
  inline ::API::Vector* release_orientation();
  inline void set_allocated_orientation(::API::Vector* orientation);

  // @@protoc_insertion_point(class_scope:API.SensorData)
 private:
  inline void set_has_accelerometer();
  inline void clear_has_accelerometer();
  inline void set_has_gyro();
  inline void clear_has_gyro();
  inline void set_has_orientation();
  inline void clear_has_orientation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::API::Motor > motor_;
  ::API::Vector* accelerometer_;
  ::API::Vector* gyro_;
  ::API::Vector* orientation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static SensorData* default_instance_;
};
// -------------------------------------------------------------------

class LocalisationFieldObject : public ::google::protobuf::Message {
 public:
  LocalisationFieldObject();
  virtual ~LocalisationFieldObject();

  LocalisationFieldObject(const LocalisationFieldObject& from);

  inline LocalisationFieldObject& operator=(const LocalisationFieldObject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalisationFieldObject& default_instance();

  void Swap(LocalisationFieldObject* other);

  // implements Message ----------------------------------------------

  LocalisationFieldObject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalisationFieldObject& from);
  void MergeFrom(const LocalisationFieldObject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional float wm_x = 2;
  inline bool has_wm_x() const;
  inline void clear_wm_x();
  static const int kWmXFieldNumber = 2;
  inline float wm_x() const;
  inline void set_wm_x(float value);

  // optional float wm_y = 3;
  inline bool has_wm_y() const;
  inline void clear_wm_y();
  static const int kWmYFieldNumber = 3;
  inline float wm_y() const;
  inline void set_wm_y(float value);

  // optional float sd_x = 4;
  inline bool has_sd_x() const;
  inline void clear_sd_x();
  static const int kSdXFieldNumber = 4;
  inline float sd_x() const;
  inline void set_sd_x(float value);

  // optional float sd_y = 5;
  inline bool has_sd_y() const;
  inline void clear_sd_y();
  static const int kSdYFieldNumber = 5;
  inline float sd_y() const;
  inline void set_sd_y(float value);

  // optional float sr_xx = 6;
  inline bool has_sr_xx() const;
  inline void clear_sr_xx();
  static const int kSrXxFieldNumber = 6;
  inline float sr_xx() const;
  inline void set_sr_xx(float value);

  // optional float sr_xy = 7;
  inline bool has_sr_xy() const;
  inline void clear_sr_xy();
  static const int kSrXyFieldNumber = 7;
  inline float sr_xy() const;
  inline void set_sr_xy(float value);

  // optional float sr_yy = 8;
  inline bool has_sr_yy() const;
  inline void clear_sr_yy();
  static const int kSrYyFieldNumber = 8;
  inline float sr_yy() const;
  inline void set_sr_yy(float value);

  // optional float heading = 9;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 9;
  inline float heading() const;
  inline void set_heading(float value);

  // optional float sd_heading = 10;
  inline bool has_sd_heading() const;
  inline void clear_sd_heading();
  static const int kSdHeadingFieldNumber = 10;
  inline float sd_heading() const;
  inline void set_sd_heading(float value);

  // optional bool lost = 11;
  inline bool has_lost() const;
  inline void clear_lost();
  static const int kLostFieldNumber = 11;
  inline bool lost() const;
  inline void set_lost(bool value);

  // @@protoc_insertion_point(class_scope:API.LocalisationFieldObject)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_wm_x();
  inline void clear_has_wm_x();
  inline void set_has_wm_y();
  inline void clear_has_wm_y();
  inline void set_has_sd_x();
  inline void clear_has_sd_x();
  inline void set_has_sd_y();
  inline void clear_has_sd_y();
  inline void set_has_sr_xx();
  inline void clear_has_sr_xx();
  inline void set_has_sr_xy();
  inline void clear_has_sr_xy();
  inline void set_has_sr_yy();
  inline void clear_has_sr_yy();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_sd_heading();
  inline void clear_has_sd_heading();
  inline void set_has_lost();
  inline void clear_has_lost();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  float wm_x_;
  float wm_y_;
  float sd_x_;
  float sd_y_;
  float sr_xx_;
  float sr_xy_;
  float sr_yy_;
  float heading_;
  float sd_heading_;
  bool lost_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static LocalisationFieldObject* default_instance_;
};
// -------------------------------------------------------------------

class Localisation : public ::google::protobuf::Message {
 public:
  Localisation();
  virtual ~Localisation();

  Localisation(const Localisation& from);

  inline Localisation& operator=(const Localisation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Localisation& default_instance();

  void Swap(Localisation* other);

  // implements Message ----------------------------------------------

  Localisation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Localisation& from);
  void MergeFrom(const Localisation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .API.LocalisationFieldObject field_object = 1;
  inline int field_object_size() const;
  inline void clear_field_object();
  static const int kFieldObjectFieldNumber = 1;
  inline const ::API::LocalisationFieldObject& field_object(int index) const;
  inline ::API::LocalisationFieldObject* mutable_field_object(int index);
  inline ::API::LocalisationFieldObject* add_field_object();
  inline const ::google::protobuf::RepeatedPtrField< ::API::LocalisationFieldObject >&
      field_object() const;
  inline ::google::protobuf::RepeatedPtrField< ::API::LocalisationFieldObject >*
      mutable_field_object();

  // @@protoc_insertion_point(class_scope:API.Localisation)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::API::LocalisationFieldObject > field_object_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static Localisation* default_instance_;
};
// -------------------------------------------------------------------

class Vector : public ::google::protobuf::Message {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();

  void Swap(Vector* other);

  // implements Message ----------------------------------------------

  Vector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float float_value = 1;
  inline int float_value_size() const;
  inline void clear_float_value();
  static const int kFloatValueFieldNumber = 1;
  inline float float_value(int index) const;
  inline void set_float_value(int index, float value);
  inline void add_float_value(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      float_value() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_float_value();

  // @@protoc_insertion_point(class_scope:API.Vector)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< float > float_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_NUAPI_2eproto();
  friend void protobuf_AssignDesc_NUAPI_2eproto();
  friend void protobuf_ShutdownFile_NUAPI_2eproto();

  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// ===================================================================


// ===================================================================

// Message

// required .API.Message.Type type = 1;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::API::Message_Type Message::type() const {
  return static_cast< ::API::Message_Type >(type_);
}
inline void Message::set_type(::API::Message_Type value) {
  assert(::API::Message_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// required uint64 utc_timestamp = 2;
inline bool Message::has_utc_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_utc_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_utc_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_utc_timestamp() {
  utc_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_utc_timestamp();
}
inline ::google::protobuf::uint64 Message::utc_timestamp() const {
  return utc_timestamp_;
}
inline void Message::set_utc_timestamp(::google::protobuf::uint64 value) {
  set_has_utc_timestamp();
  utc_timestamp_ = value;
}

// optional .API.SensorData sensor_data = 3;
inline bool Message::has_sensor_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_sensor_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_sensor_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_sensor_data() {
  if (sensor_data_ != NULL) sensor_data_->::API::SensorData::Clear();
  clear_has_sensor_data();
}
inline const ::API::SensorData& Message::sensor_data() const {
  return sensor_data_ != NULL ? *sensor_data_ : *default_instance_->sensor_data_;
}
inline ::API::SensorData* Message::mutable_sensor_data() {
  set_has_sensor_data();
  if (sensor_data_ == NULL) sensor_data_ = new ::API::SensorData;
  return sensor_data_;
}
inline ::API::SensorData* Message::release_sensor_data() {
  clear_has_sensor_data();
  ::API::SensorData* temp = sensor_data_;
  sensor_data_ = NULL;
  return temp;
}
inline void Message::set_allocated_sensor_data(::API::SensorData* sensor_data) {
  delete sensor_data_;
  sensor_data_ = sensor_data;
  if (sensor_data) {
    set_has_sensor_data();
  } else {
    clear_has_sensor_data();
  }
}

// optional .API.Vision vision = 4;
inline bool Message::has_vision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_vision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_vision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_vision() {
  if (vision_ != NULL) vision_->::API::Vision::Clear();
  clear_has_vision();
}
inline const ::API::Vision& Message::vision() const {
  return vision_ != NULL ? *vision_ : *default_instance_->vision_;
}
inline ::API::Vision* Message::mutable_vision() {
  set_has_vision();
  if (vision_ == NULL) vision_ = new ::API::Vision;
  return vision_;
}
inline ::API::Vision* Message::release_vision() {
  clear_has_vision();
  ::API::Vision* temp = vision_;
  vision_ = NULL;
  return temp;
}
inline void Message::set_allocated_vision(::API::Vision* vision) {
  delete vision_;
  vision_ = vision;
  if (vision) {
    set_has_vision();
  } else {
    clear_has_vision();
  }
}

// optional .API.Localisation localisation = 5;
inline bool Message::has_localisation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_localisation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_localisation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_localisation() {
  if (localisation_ != NULL) localisation_->::API::Localisation::Clear();
  clear_has_localisation();
}
inline const ::API::Localisation& Message::localisation() const {
  return localisation_ != NULL ? *localisation_ : *default_instance_->localisation_;
}
inline ::API::Localisation* Message::mutable_localisation() {
  set_has_localisation();
  if (localisation_ == NULL) localisation_ = new ::API::Localisation;
  return localisation_;
}
inline ::API::Localisation* Message::release_localisation() {
  clear_has_localisation();
  ::API::Localisation* temp = localisation_;
  localisation_ = NULL;
  return temp;
}
inline void Message::set_allocated_localisation(::API::Localisation* localisation) {
  delete localisation_;
  localisation_ = localisation;
  if (localisation) {
    set_has_localisation();
  } else {
    clear_has_localisation();
  }
}

// -------------------------------------------------------------------

// Image

// optional uint32 width = 1;
inline bool Image::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Image::width() const {
  return width_;
}
inline void Image::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 height = 2;
inline bool Image::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Image::height() const {
  return height_;
}
inline void Image::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// optional bytes data = 3;
inline bool Image::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Image::data() const {
  return *data_;
}
inline void Image::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Image::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void Image::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Image::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* Image::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Image::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// VisionFieldObject

// optional .API.VisionFieldObject.Type type = 1;
inline bool VisionFieldObject::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisionFieldObject::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisionFieldObject::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisionFieldObject::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::API::VisionFieldObject_Type VisionFieldObject::type() const {
  return static_cast< ::API::VisionFieldObject_Type >(type_);
}
inline void VisionFieldObject::set_type(::API::VisionFieldObject_Type value) {
  assert(::API::VisionFieldObject_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 id = 2;
inline bool VisionFieldObject::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VisionFieldObject::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VisionFieldObject::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VisionFieldObject::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 VisionFieldObject::id() const {
  return id_;
}
inline void VisionFieldObject::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 3;
inline bool VisionFieldObject::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VisionFieldObject::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VisionFieldObject::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VisionFieldObject::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& VisionFieldObject::name() const {
  return *name_;
}
inline void VisionFieldObject::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VisionFieldObject::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void VisionFieldObject::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VisionFieldObject::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* VisionFieldObject::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VisionFieldObject::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool visible = 4;
inline bool VisionFieldObject::has_visible() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VisionFieldObject::set_has_visible() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VisionFieldObject::clear_has_visible() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VisionFieldObject::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool VisionFieldObject::visible() const {
  return visible_;
}
inline void VisionFieldObject::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional float screen_x = 5;
inline bool VisionFieldObject::has_screen_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VisionFieldObject::set_has_screen_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VisionFieldObject::clear_has_screen_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VisionFieldObject::clear_screen_x() {
  screen_x_ = 0;
  clear_has_screen_x();
}
inline float VisionFieldObject::screen_x() const {
  return screen_x_;
}
inline void VisionFieldObject::set_screen_x(float value) {
  set_has_screen_x();
  screen_x_ = value;
}

// optional float screen_y = 6;
inline bool VisionFieldObject::has_screen_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VisionFieldObject::set_has_screen_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VisionFieldObject::clear_has_screen_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VisionFieldObject::clear_screen_y() {
  screen_y_ = 0;
  clear_has_screen_y();
}
inline float VisionFieldObject::screen_y() const {
  return screen_y_;
}
inline void VisionFieldObject::set_screen_y(float value) {
  set_has_screen_y();
  screen_y_ = value;
}

// optional float rotation = 7;
inline bool VisionFieldObject::has_rotation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VisionFieldObject::set_has_rotation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VisionFieldObject::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VisionFieldObject::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float VisionFieldObject::rotation() const {
  return rotation_;
}
inline void VisionFieldObject::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional uint32 radius = 8;
inline bool VisionFieldObject::has_radius() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VisionFieldObject::set_has_radius() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VisionFieldObject::clear_has_radius() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VisionFieldObject::clear_radius() {
  radius_ = 0u;
  clear_has_radius();
}
inline ::google::protobuf::uint32 VisionFieldObject::radius() const {
  return radius_;
}
inline void VisionFieldObject::set_radius(::google::protobuf::uint32 value) {
  set_has_radius();
  radius_ = value;
}

// optional uint32 width = 9;
inline bool VisionFieldObject::has_width() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VisionFieldObject::set_has_width() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VisionFieldObject::clear_has_width() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VisionFieldObject::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 VisionFieldObject::width() const {
  return width_;
}
inline void VisionFieldObject::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional uint32 height = 10;
inline bool VisionFieldObject::has_height() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VisionFieldObject::set_has_height() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VisionFieldObject::clear_has_height() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VisionFieldObject::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 VisionFieldObject::height() const {
  return height_;
}
inline void VisionFieldObject::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
}

// repeated uint32 points = 11;
inline int VisionFieldObject::points_size() const {
  return points_.size();
}
inline void VisionFieldObject::clear_points() {
  points_.Clear();
}
inline ::google::protobuf::uint32 VisionFieldObject::points(int index) const {
  return points_.Get(index);
}
inline void VisionFieldObject::set_points(int index, ::google::protobuf::uint32 value) {
  points_.Set(index, value);
}
inline void VisionFieldObject::add_points(::google::protobuf::uint32 value) {
  points_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VisionFieldObject::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VisionFieldObject::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// VisionClassifiedSegment

// optional uint32 start_x = 1;
inline bool VisionClassifiedSegment::has_start_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisionClassifiedSegment::set_has_start_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisionClassifiedSegment::clear_has_start_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisionClassifiedSegment::clear_start_x() {
  start_x_ = 0u;
  clear_has_start_x();
}
inline ::google::protobuf::uint32 VisionClassifiedSegment::start_x() const {
  return start_x_;
}
inline void VisionClassifiedSegment::set_start_x(::google::protobuf::uint32 value) {
  set_has_start_x();
  start_x_ = value;
}

// optional uint32 start_y = 2;
inline bool VisionClassifiedSegment::has_start_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VisionClassifiedSegment::set_has_start_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VisionClassifiedSegment::clear_has_start_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VisionClassifiedSegment::clear_start_y() {
  start_y_ = 0u;
  clear_has_start_y();
}
inline ::google::protobuf::uint32 VisionClassifiedSegment::start_y() const {
  return start_y_;
}
inline void VisionClassifiedSegment::set_start_y(::google::protobuf::uint32 value) {
  set_has_start_y();
  start_y_ = value;
}

// optional uint32 end_x = 3;
inline bool VisionClassifiedSegment::has_end_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VisionClassifiedSegment::set_has_end_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VisionClassifiedSegment::clear_has_end_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VisionClassifiedSegment::clear_end_x() {
  end_x_ = 0u;
  clear_has_end_x();
}
inline ::google::protobuf::uint32 VisionClassifiedSegment::end_x() const {
  return end_x_;
}
inline void VisionClassifiedSegment::set_end_x(::google::protobuf::uint32 value) {
  set_has_end_x();
  end_x_ = value;
}

// optional uint32 end_y = 4;
inline bool VisionClassifiedSegment::has_end_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VisionClassifiedSegment::set_has_end_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VisionClassifiedSegment::clear_has_end_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VisionClassifiedSegment::clear_end_y() {
  end_y_ = 0u;
  clear_has_end_y();
}
inline ::google::protobuf::uint32 VisionClassifiedSegment::end_y() const {
  return end_y_;
}
inline void VisionClassifiedSegment::set_end_y(::google::protobuf::uint32 value) {
  set_has_end_y();
  end_y_ = value;
}

// optional uint32 colour = 5;
inline bool VisionClassifiedSegment::has_colour() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VisionClassifiedSegment::set_has_colour() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VisionClassifiedSegment::clear_has_colour() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VisionClassifiedSegment::clear_colour() {
  colour_ = 0u;
  clear_has_colour();
}
inline ::google::protobuf::uint32 VisionClassifiedSegment::colour() const {
  return colour_;
}
inline void VisionClassifiedSegment::set_colour(::google::protobuf::uint32 value) {
  set_has_colour();
  colour_ = value;
}

// -------------------------------------------------------------------

// VisionClassifiedImage

// optional uint32 num_segments = 1;
inline bool VisionClassifiedImage::has_num_segments() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VisionClassifiedImage::set_has_num_segments() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VisionClassifiedImage::clear_has_num_segments() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VisionClassifiedImage::clear_num_segments() {
  num_segments_ = 0u;
  clear_has_num_segments();
}
inline ::google::protobuf::uint32 VisionClassifiedImage::num_segments() const {
  return num_segments_;
}
inline void VisionClassifiedImage::set_num_segments(::google::protobuf::uint32 value) {
  set_has_num_segments();
  num_segments_ = value;
}

// repeated .API.VisionClassifiedSegment segment = 2;
inline int VisionClassifiedImage::segment_size() const {
  return segment_.size();
}
inline void VisionClassifiedImage::clear_segment() {
  segment_.Clear();
}
inline const ::API::VisionClassifiedSegment& VisionClassifiedImage::segment(int index) const {
  return segment_.Get(index);
}
inline ::API::VisionClassifiedSegment* VisionClassifiedImage::mutable_segment(int index) {
  return segment_.Mutable(index);
}
inline ::API::VisionClassifiedSegment* VisionClassifiedImage::add_segment() {
  return segment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::API::VisionClassifiedSegment >&
VisionClassifiedImage::segment() const {
  return segment_;
}
inline ::google::protobuf::RepeatedPtrField< ::API::VisionClassifiedSegment >*
VisionClassifiedImage::mutable_segment() {
  return &segment_;
}

// -------------------------------------------------------------------

// Vision

// optional .API.Image image = 1;
inline bool Vision::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vision::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vision::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vision::clear_image() {
  if (image_ != NULL) image_->::API::Image::Clear();
  clear_has_image();
}
inline const ::API::Image& Vision::image() const {
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::API::Image* Vision::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::API::Image;
  return image_;
}
inline ::API::Image* Vision::release_image() {
  clear_has_image();
  ::API::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void Vision::set_allocated_image(::API::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
}

// repeated .API.VisionFieldObject field_object = 2;
inline int Vision::field_object_size() const {
  return field_object_.size();
}
inline void Vision::clear_field_object() {
  field_object_.Clear();
}
inline const ::API::VisionFieldObject& Vision::field_object(int index) const {
  return field_object_.Get(index);
}
inline ::API::VisionFieldObject* Vision::mutable_field_object(int index) {
  return field_object_.Mutable(index);
}
inline ::API::VisionFieldObject* Vision::add_field_object() {
  return field_object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::API::VisionFieldObject >&
Vision::field_object() const {
  return field_object_;
}
inline ::google::protobuf::RepeatedPtrField< ::API::VisionFieldObject >*
Vision::mutable_field_object() {
  return &field_object_;
}

// optional .API.VisionClassifiedImage classified_image = 3;
inline bool Vision::has_classified_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vision::set_has_classified_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vision::clear_has_classified_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vision::clear_classified_image() {
  if (classified_image_ != NULL) classified_image_->::API::VisionClassifiedImage::Clear();
  clear_has_classified_image();
}
inline const ::API::VisionClassifiedImage& Vision::classified_image() const {
  return classified_image_ != NULL ? *classified_image_ : *default_instance_->classified_image_;
}
inline ::API::VisionClassifiedImage* Vision::mutable_classified_image() {
  set_has_classified_image();
  if (classified_image_ == NULL) classified_image_ = new ::API::VisionClassifiedImage;
  return classified_image_;
}
inline ::API::VisionClassifiedImage* Vision::release_classified_image() {
  clear_has_classified_image();
  ::API::VisionClassifiedImage* temp = classified_image_;
  classified_image_ = NULL;
  return temp;
}
inline void Vision::set_allocated_classified_image(::API::VisionClassifiedImage* classified_image) {
  delete classified_image_;
  classified_image_ = classified_image;
  if (classified_image) {
    set_has_classified_image();
  } else {
    clear_has_classified_image();
  }
}

// -------------------------------------------------------------------

// Motor

// optional string name = 1;
inline bool Motor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Motor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Motor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Motor::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Motor::name() const {
  return *name_;
}
inline void Motor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Motor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Motor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Motor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Motor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Motor::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float position = 2;
inline bool Motor::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Motor::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Motor::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Motor::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline float Motor::position() const {
  return position_;
}
inline void Motor::set_position(float value) {
  set_has_position();
  position_ = value;
}

// optional float velocity = 3;
inline bool Motor::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Motor::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Motor::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Motor::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float Motor::velocity() const {
  return velocity_;
}
inline void Motor::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
}

// optional float acceleration = 4;
inline bool Motor::has_acceleration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Motor::set_has_acceleration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Motor::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Motor::clear_acceleration() {
  acceleration_ = 0;
  clear_has_acceleration();
}
inline float Motor::acceleration() const {
  return acceleration_;
}
inline void Motor::set_acceleration(float value) {
  set_has_acceleration();
  acceleration_ = value;
}

// optional float target = 5;
inline bool Motor::has_target() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Motor::set_has_target() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Motor::clear_has_target() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Motor::clear_target() {
  target_ = 0;
  clear_has_target();
}
inline float Motor::target() const {
  return target_;
}
inline void Motor::set_target(float value) {
  set_has_target();
  target_ = value;
}

// optional float stiffness = 6;
inline bool Motor::has_stiffness() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Motor::set_has_stiffness() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Motor::clear_has_stiffness() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Motor::clear_stiffness() {
  stiffness_ = 0;
  clear_has_stiffness();
}
inline float Motor::stiffness() const {
  return stiffness_;
}
inline void Motor::set_stiffness(float value) {
  set_has_stiffness();
  stiffness_ = value;
}

// optional float current = 7;
inline bool Motor::has_current() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Motor::set_has_current() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Motor::clear_has_current() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Motor::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline float Motor::current() const {
  return current_;
}
inline void Motor::set_current(float value) {
  set_has_current();
  current_ = value;
}

// optional float torque = 8;
inline bool Motor::has_torque() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Motor::set_has_torque() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Motor::clear_has_torque() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Motor::clear_torque() {
  torque_ = 0;
  clear_has_torque();
}
inline float Motor::torque() const {
  return torque_;
}
inline void Motor::set_torque(float value) {
  set_has_torque();
  torque_ = value;
}

// optional float temperature = 9;
inline bool Motor::has_temperature() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Motor::set_has_temperature() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Motor::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Motor::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline float Motor::temperature() const {
  return temperature_;
}
inline void Motor::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
}

// -------------------------------------------------------------------

// SensorData

// repeated .API.Motor motor = 1;
inline int SensorData::motor_size() const {
  return motor_.size();
}
inline void SensorData::clear_motor() {
  motor_.Clear();
}
inline const ::API::Motor& SensorData::motor(int index) const {
  return motor_.Get(index);
}
inline ::API::Motor* SensorData::mutable_motor(int index) {
  return motor_.Mutable(index);
}
inline ::API::Motor* SensorData::add_motor() {
  return motor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::API::Motor >&
SensorData::motor() const {
  return motor_;
}
inline ::google::protobuf::RepeatedPtrField< ::API::Motor >*
SensorData::mutable_motor() {
  return &motor_;
}

// optional .API.Vector accelerometer = 2;
inline bool SensorData::has_accelerometer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorData::set_has_accelerometer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorData::clear_has_accelerometer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorData::clear_accelerometer() {
  if (accelerometer_ != NULL) accelerometer_->::API::Vector::Clear();
  clear_has_accelerometer();
}
inline const ::API::Vector& SensorData::accelerometer() const {
  return accelerometer_ != NULL ? *accelerometer_ : *default_instance_->accelerometer_;
}
inline ::API::Vector* SensorData::mutable_accelerometer() {
  set_has_accelerometer();
  if (accelerometer_ == NULL) accelerometer_ = new ::API::Vector;
  return accelerometer_;
}
inline ::API::Vector* SensorData::release_accelerometer() {
  clear_has_accelerometer();
  ::API::Vector* temp = accelerometer_;
  accelerometer_ = NULL;
  return temp;
}
inline void SensorData::set_allocated_accelerometer(::API::Vector* accelerometer) {
  delete accelerometer_;
  accelerometer_ = accelerometer;
  if (accelerometer) {
    set_has_accelerometer();
  } else {
    clear_has_accelerometer();
  }
}

// optional .API.Vector gyro = 3;
inline bool SensorData::has_gyro() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorData::set_has_gyro() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorData::clear_has_gyro() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorData::clear_gyro() {
  if (gyro_ != NULL) gyro_->::API::Vector::Clear();
  clear_has_gyro();
}
inline const ::API::Vector& SensorData::gyro() const {
  return gyro_ != NULL ? *gyro_ : *default_instance_->gyro_;
}
inline ::API::Vector* SensorData::mutable_gyro() {
  set_has_gyro();
  if (gyro_ == NULL) gyro_ = new ::API::Vector;
  return gyro_;
}
inline ::API::Vector* SensorData::release_gyro() {
  clear_has_gyro();
  ::API::Vector* temp = gyro_;
  gyro_ = NULL;
  return temp;
}
inline void SensorData::set_allocated_gyro(::API::Vector* gyro) {
  delete gyro_;
  gyro_ = gyro;
  if (gyro) {
    set_has_gyro();
  } else {
    clear_has_gyro();
  }
}

// optional .API.Vector orientation = 4;
inline bool SensorData::has_orientation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorData::set_has_orientation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorData::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorData::clear_orientation() {
  if (orientation_ != NULL) orientation_->::API::Vector::Clear();
  clear_has_orientation();
}
inline const ::API::Vector& SensorData::orientation() const {
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::API::Vector* SensorData::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) orientation_ = new ::API::Vector;
  return orientation_;
}
inline ::API::Vector* SensorData::release_orientation() {
  clear_has_orientation();
  ::API::Vector* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void SensorData::set_allocated_orientation(::API::Vector* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
}

// -------------------------------------------------------------------

// LocalisationFieldObject

// optional string name = 1;
inline bool LocalisationFieldObject::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalisationFieldObject::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalisationFieldObject::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalisationFieldObject::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LocalisationFieldObject::name() const {
  return *name_;
}
inline void LocalisationFieldObject::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LocalisationFieldObject::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LocalisationFieldObject::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalisationFieldObject::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LocalisationFieldObject::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LocalisationFieldObject::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float wm_x = 2;
inline bool LocalisationFieldObject::has_wm_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalisationFieldObject::set_has_wm_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalisationFieldObject::clear_has_wm_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalisationFieldObject::clear_wm_x() {
  wm_x_ = 0;
  clear_has_wm_x();
}
inline float LocalisationFieldObject::wm_x() const {
  return wm_x_;
}
inline void LocalisationFieldObject::set_wm_x(float value) {
  set_has_wm_x();
  wm_x_ = value;
}

// optional float wm_y = 3;
inline bool LocalisationFieldObject::has_wm_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalisationFieldObject::set_has_wm_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalisationFieldObject::clear_has_wm_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalisationFieldObject::clear_wm_y() {
  wm_y_ = 0;
  clear_has_wm_y();
}
inline float LocalisationFieldObject::wm_y() const {
  return wm_y_;
}
inline void LocalisationFieldObject::set_wm_y(float value) {
  set_has_wm_y();
  wm_y_ = value;
}

// optional float sd_x = 4;
inline bool LocalisationFieldObject::has_sd_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocalisationFieldObject::set_has_sd_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocalisationFieldObject::clear_has_sd_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocalisationFieldObject::clear_sd_x() {
  sd_x_ = 0;
  clear_has_sd_x();
}
inline float LocalisationFieldObject::sd_x() const {
  return sd_x_;
}
inline void LocalisationFieldObject::set_sd_x(float value) {
  set_has_sd_x();
  sd_x_ = value;
}

// optional float sd_y = 5;
inline bool LocalisationFieldObject::has_sd_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalisationFieldObject::set_has_sd_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalisationFieldObject::clear_has_sd_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalisationFieldObject::clear_sd_y() {
  sd_y_ = 0;
  clear_has_sd_y();
}
inline float LocalisationFieldObject::sd_y() const {
  return sd_y_;
}
inline void LocalisationFieldObject::set_sd_y(float value) {
  set_has_sd_y();
  sd_y_ = value;
}

// optional float sr_xx = 6;
inline bool LocalisationFieldObject::has_sr_xx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocalisationFieldObject::set_has_sr_xx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocalisationFieldObject::clear_has_sr_xx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocalisationFieldObject::clear_sr_xx() {
  sr_xx_ = 0;
  clear_has_sr_xx();
}
inline float LocalisationFieldObject::sr_xx() const {
  return sr_xx_;
}
inline void LocalisationFieldObject::set_sr_xx(float value) {
  set_has_sr_xx();
  sr_xx_ = value;
}

// optional float sr_xy = 7;
inline bool LocalisationFieldObject::has_sr_xy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LocalisationFieldObject::set_has_sr_xy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LocalisationFieldObject::clear_has_sr_xy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LocalisationFieldObject::clear_sr_xy() {
  sr_xy_ = 0;
  clear_has_sr_xy();
}
inline float LocalisationFieldObject::sr_xy() const {
  return sr_xy_;
}
inline void LocalisationFieldObject::set_sr_xy(float value) {
  set_has_sr_xy();
  sr_xy_ = value;
}

// optional float sr_yy = 8;
inline bool LocalisationFieldObject::has_sr_yy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LocalisationFieldObject::set_has_sr_yy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LocalisationFieldObject::clear_has_sr_yy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LocalisationFieldObject::clear_sr_yy() {
  sr_yy_ = 0;
  clear_has_sr_yy();
}
inline float LocalisationFieldObject::sr_yy() const {
  return sr_yy_;
}
inline void LocalisationFieldObject::set_sr_yy(float value) {
  set_has_sr_yy();
  sr_yy_ = value;
}

// optional float heading = 9;
inline bool LocalisationFieldObject::has_heading() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LocalisationFieldObject::set_has_heading() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LocalisationFieldObject::clear_has_heading() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LocalisationFieldObject::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float LocalisationFieldObject::heading() const {
  return heading_;
}
inline void LocalisationFieldObject::set_heading(float value) {
  set_has_heading();
  heading_ = value;
}

// optional float sd_heading = 10;
inline bool LocalisationFieldObject::has_sd_heading() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LocalisationFieldObject::set_has_sd_heading() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LocalisationFieldObject::clear_has_sd_heading() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LocalisationFieldObject::clear_sd_heading() {
  sd_heading_ = 0;
  clear_has_sd_heading();
}
inline float LocalisationFieldObject::sd_heading() const {
  return sd_heading_;
}
inline void LocalisationFieldObject::set_sd_heading(float value) {
  set_has_sd_heading();
  sd_heading_ = value;
}

// optional bool lost = 11;
inline bool LocalisationFieldObject::has_lost() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LocalisationFieldObject::set_has_lost() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LocalisationFieldObject::clear_has_lost() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LocalisationFieldObject::clear_lost() {
  lost_ = false;
  clear_has_lost();
}
inline bool LocalisationFieldObject::lost() const {
  return lost_;
}
inline void LocalisationFieldObject::set_lost(bool value) {
  set_has_lost();
  lost_ = value;
}

// -------------------------------------------------------------------

// Localisation

// repeated .API.LocalisationFieldObject field_object = 1;
inline int Localisation::field_object_size() const {
  return field_object_.size();
}
inline void Localisation::clear_field_object() {
  field_object_.Clear();
}
inline const ::API::LocalisationFieldObject& Localisation::field_object(int index) const {
  return field_object_.Get(index);
}
inline ::API::LocalisationFieldObject* Localisation::mutable_field_object(int index) {
  return field_object_.Mutable(index);
}
inline ::API::LocalisationFieldObject* Localisation::add_field_object() {
  return field_object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::API::LocalisationFieldObject >&
Localisation::field_object() const {
  return field_object_;
}
inline ::google::protobuf::RepeatedPtrField< ::API::LocalisationFieldObject >*
Localisation::mutable_field_object() {
  return &field_object_;
}

// -------------------------------------------------------------------

// Vector

// repeated float float_value = 1;
inline int Vector::float_value_size() const {
  return float_value_.size();
}
inline void Vector::clear_float_value() {
  float_value_.Clear();
}
inline float Vector::float_value(int index) const {
  return float_value_.Get(index);
}
inline void Vector::set_float_value(int index, float value) {
  float_value_.Set(index, value);
}
inline void Vector::add_float_value(float value) {
  float_value_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Vector::float_value() const {
  return float_value_;
}
inline ::google::protobuf::RepeatedField< float >*
Vector::mutable_float_value() {
  return &float_value_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace API

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::API::Message_Type>() {
  return ::API::Message_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::API::VisionFieldObject_Type>() {
  return ::API::VisionFieldObject_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NUAPI_2eproto__INCLUDED
