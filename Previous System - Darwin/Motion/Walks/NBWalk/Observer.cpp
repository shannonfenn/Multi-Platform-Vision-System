
// This file is part of Man, a robotic perception, locomotion, and
// team strategy application created by the Northern Bites RoboCup
// team of Bowdoin College in Brunswick, Maine, for the Aldebaran
// Nao robot.
//
// Man is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Man is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser Public License for more details.
//
// You should have received a copy of the GNU General Public License
// and the GNU Lesser Public License along with Man.  If not, see
// <http://www.gnu.org/licenses/>.

#include "Observer.h"
using std::list;

using namespace NBMath;

#if defined(TARGET_IS_NAO)
    // generated by octave for the NAO (10ms motion frame period)
    const float Observer::weights[NUM_AVAIL_PREVIEW_FRAMES] = 
    {59.398850, 94.740387, 103.828147, 102.692560, 98.255666, 92.929737, 87.528720, 82.317724,
        77.374571, 72.713695, 68.328552, 64.206101, 60.331728, 56.690891, 53.269647, 50.054799,
        47.033916, 44.195302, 41.527965, 39.021572, 36.666416, 34.453373, 32.373869, 30.419850,
        28.583743, 26.858436, 25.237244, 23.713886, 22.282459, 20.937417, 19.673547, 18.485952,
        17.370030, 16.321457, 15.336168, 14.410346, 13.540401, 12.722963, 11.954862, 11.233122,
        10.554946, 9.917704, 9.318926, 8.756290, 8.227617, 7.730856, 7.264082, 6.825484,
        6.413362, 6.026119, 5.662253, 5.320353, 4.999093, 4.697227, 4.413585, 4.147068,
        3.896640, 3.661332, 3.440230, 3.232478, 3.037269, 2.853846, 2.681497, 2.519555,
        2.367391, 2.224414, 2.090071, 1.963839, 1.845230, 1.733783, 1.629066, 1.530672,
        1.438219, 1.351350, 1.269726, 1.193032, 1.120969, 1.053258, 0.989636, 0.929857,
        0.873687, 0.820910, 0.771321, 0.724726, 0.680946, 0.639810, 0.601158, 0.564841,
        0.530717, 0.498655, 0.468529, 0.440223, 0.413626, 0.388636, 0.365156, 0.343094,
        0.322364, 0.302887, 0.284587, 0.267391, 0.251235, 0.236055, 0.221791, 0.208390,
        0.195798, 0.183966, 0.172850, 0.162405, 0.152591, 0.143370, 0.134706, 0.126566,
        0.118917, 0.111731, 0.104979, 0.098635, 0.092674, 0.087073, 0.081811, 0.076866,
    };

    const float Observer::A_values[9] = 
    {1.000000, 0.010000, 0.000000,
        0.426087, 1.000000, -0.426087,
        22.039667, 3.376416, -1.338756,
    };

    const float Observer::b_values[3] = {0.000000, 0.000000, 0.010000};

    const float Observer::L_values[3] = {0.044562, -0.381543, -0.275614};

    const float Observer::c_values[3] = {0.000000, 0.000000, 1.000000};

    const float Observer::Gi = -59.339510;
#elif defined(TARGET_IS_NAOWEBOTS)
    // generated by octave for the NAO in Webots platform
    const float Observer::weights[NUM_AVAIL_PREVIEW_FRAMES] = 
    {12.895051, 19.597614, 18.906417, 16.214138, 13.316934, 10.745156, 8.604398, 6.867297,
        5.472855, 4.358705, 3.470338, 2.762648, 2.199120, 1.750474, 1.393321, 1.109018,
        0.882712, 0.702575, 0.559191, 0.445064, 0.354224, 0.281921, 0.224373, 0.178570,
        0.142115, 0.113101, 0.090009, 0.071631, 0.057005, 0.045365, };

    const float Observer::A_values[9] = 
    {1.000000, 0.040000, 0.000000,
        1.704348, 1.000000, -1.704348,
        7.870146, 1.205684, -1.628903,
    };

    const float Observer::b_values[3] = {0.000000, 0.000000, 0.040000};

    const float Observer::L_values[3] = {0.131770, -1.265416, -0.386921};

    const float Observer::c_values[3] = {0.000000, 0.000000, 1.000000};

    const float Observer::Gi = -12.843677;
#endif

Observer::Observer()
    : WalkController(), stateVector(ufvector3(3)),
      A(ufmatrix3(3,3)), b(ufvector3(3)), c(ufrowVector3(1,3)),
      L(ufvector3(3)),trackingError(0.0f)
      {
    // instantiate the ublas matrices with their respective values
    // TODO: there might be a better way to do this.
    for (int i=0; i < 3; i++)
        stateVector(i) = 0.0f;

    for (int i=0; i < 3; i++)
        A(0, i) = A_values[i];
    for (int i=0; i < 3; i++)
        A(1, i) = A_values[3+i];
    for (int i=0; i < 3; i++)
        A(2, i) = A_values[6+i];

    for (int i=0; i < 3; i++)
        b(i) = b_values[i];

    for (int i=0; i < 3; i++)
        c(0,i) = c_values[i];

    for (int i=0; i < 3; i++)
        L(i) = L_values[i];

#ifdef DEBUG_CONTROLLER_GAINS
    FILE * gains_log;
    gains_log = fopen("/tmp/gains_log.xls","w");
    int j = 0;
    fprintf(gains_log,"time\tgain\n");
    //write the controller gains
    for(unsigned int i  = 0; i < NUM_PREVIEW_FRAMES; i++){
        fprintf(gains_log,"%d\t%f\n",j,weights[j]);
        j++;
    }
    fclose(gains_log);
#endif

}

/**
 * Tick calculates the next state vector for the robot, given the zmp_ref
 *
 */
const float Observer::tick(const list<float> *zmp_ref,
                           const float cur_zmp_ref,
                           const float sensor_zmp) {
    float preview_control = 0.0f;
    unsigned int counter = 0;

    for (list<float>::const_iterator i = zmp_ref->begin();
         counter < NUM_PREVIEW_FRAMES; ++counter, ++i) {
        preview_control += weights[counter]* (*i);
    }

    trackingError += prod(c,stateVector)(0) - cur_zmp_ref;

    const float control = -Gi * trackingError - preview_control;
    const float psensor = sensor_zmp;

    ufvector3 temp(prod(A, stateVector)
                   - L*(psensor - prod(c,stateVector)(0)) * 1.0f
                   + b*control);
    stateVector.assign(temp);

    return getPosition();
}

/**
 * Initialize the position of the robot (vel and accel assumed to be 0)
 * We also assume we are starting off without any tracking error.
 */
void Observer::initState(float x, float v, float p){
    stateVector(0) = x;
    stateVector(1) = v;
    stateVector(2) = p;
    trackingError = 0.0f;
}
